<?php defined('SYS_PATH') OR die('No direct script access.');/** * 防止CSRF攻击 * * @package		Kohana * @category	Security * @author     YwiSax * @copyright  (c) 2009 XunSec Team * @license    http://www.xunsec.com/license */class Kohana_Security_CSRF extends Security {	/**	 * @var  string  用于保存令牌的key	 */	public static $token_name = 'security_token';	/**	 * 生成一个随机令牌，这个是用用户防止[CSRF](http://wikipedia.org/wiki/Cross_Site_Request_Forgery)攻击的。	 *	 *     $token = Security_CSRF::token();	 *	 * 在表单中使用：	 *	 *     echo Helper_Form::hidden('csrf', Security_CSRF::token());	 *	 * 然后在验证中使用以下代码：	 *	 *     $array->rules('csrf', array(	 *         'not_empty'				=> NULL,	 *         'Security_CSRF::check'	=> NULL,	 *     ));	 *	 * 这是一个很基础，但是同时很实用的方法。	 *	 * @param   boolean $new    force a new token to be generated?	 * @return  string	 */	public static function token($new = FALSE)	{		$session = Session::instance();		// 当前token		$token = $session->get(Security_CSRF::$token_name);		if ($new === TRUE OR ! $token)		{			// 生成一个唯一token			$token = sha1(uniqid(NULL, TRUE));			// 保存新的token			$session->set(Security_CSRF::$token_name, $token);		}		return $token;	}	/**	 * 检查token是否正确	 *	 *     if (Security_CSRF::check($token))	 *     {	 *         // OK	 *     }	 *	 * @param   string  $token  要检查的token	 * @return  boolean	 */	public static function check($token)	{		return Security_CSRF::token() === $token;	}} // End Security_CSRF